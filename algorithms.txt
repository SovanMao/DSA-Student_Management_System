// -------------------- DATA STRUCTURE DEFINITIONS --------------------
Struct Student
    var id: integer
    var name: string
    var score: double
    var major: string
    var valid: boolean

    procedure display()
    begin
        write("ID: " + id + " | Name: " + name + " | Major: " + major + " | Score: " + score)
    end procedure
end struct

Struct Node
    var action: string
    var id: integer
    var *next: Node
end struct

Struct TreeNode
    var data: Student
    var *left: TreeNode
    var *right: TreeNode
end struct

// -------------------- GLOBAL CONSTANTS AND VARIABLES --------------------
constant MAX <- 100
var students: array [MAX] of Student    // Main array storage
var studentCount: integer <- 0          // Current number of records in the array
var nextId: integer <- 1                // Next ID to assign
var *history: Node <- null    // Linked List head for record history
var undoStack: Stack of Student         // Stack for undo operations
var redoStack: Stack of Student         // Stack for redo operations
var printQueue: Queue of integer        // Queue for print requests (stores Student IDs)

// --------------------------- Array Manager ---------------------------

procedure addStudent()
begin
    if (studentCount >= MAX) then
        write("Storage full!")
        return
    end if
    var s: Student
    s->id <- nextId
    nextId <- nextId + 1
    
    write("Enter name: ")
    read(s.name)     
    write("Enter major: ")
    read(s.major)
    write("Enter score: ")
    read(s.score)
    s.valid <- true
    
    var state_before_add: Student <- s
    state_before_add.valid <- false
    undoStack.push(state_before_add)

    while (redoStack != null) do
        redoStack.pop()
    end while
    
    students[studentCount] <- s
    studentCount <- studentCount + 1
    write("Student added successfully!")
end procedure

procedure showStudents()
begin
    write("--- Student List ---")
    var anyPrinted: boolean <- false
    for ( var i : integer <-0, i < studentCount, i++) do
        if (students[i].valid) then
            students[i].display()
            anyPrinted <- true
        end if
    end for
    if (!anyPrinted) then
        write("No students to show.")
    end if
end procedure

function findStudent(var id: integer) : integer
begin
    for (var i : integer <-0, i < studentCount, i++) do
        if (students[i].id == id) then
            return i
        end if
    end for
    return -1
end function

procedure searchStudent()
begin
    if (studentCount == 0) then
        write("No students to search!")
        return
    end if
    
    var id: integer
    write("--- SEARCH STUDENT ---")
    write("Enter student ID: ")
    read(id)
    
    var idx: integer <- findStudent(id)
    if (idx != -1 AND students[idx].valid) then
        write("Student found at position " + (idx + 1) + ":")
        students[idx].display()
    else
        write("Student not found!")
    end if
end procedure

procedure deleteStudent()
begin
    var id: integer
    write("Enter ID to delete: ")
    read(id)
    idx <- findStudent(id)
    if (idx == -1) then
        write("Student not found!")
        return
    end if
    
    undoStack.push(students[idx])
    
    while (redoStack != null) do
        redoStack.pop()
    end while
    
    students[idx].valid <- false
    write("Deleted successfully.")
end procedure

// --------------------------- Recursive Report ---------------------------

procedure recursiveReport(var i: integer, ref pass: integer, ref fail: integer, ref out: integer)
begin
    if (i >= studentCount) then
        return
    end if
    if (students[i].valid) then
        if (students[i].score >= 85) then
            out <- out + 1
        end if
        if (students[i].score >= 50) then
            pass <- pass + 1
        else
            fail <- fail + 1
        end if
    end if
    recursiveReport(i + 1, pass, fail, out)
end procedure

procedure showReport()
begin
    var pass: integer <- 0
    var fail: integer <- 0
    var out: integer <- 0
    recursiveReport(0, pass, fail, out)
    write("--- Student Report ---")
    write("Passed: " + pass)
    write("Failed: " + fail)
    write("Outstanding: " + out)
end procedure

// --------------------------- Pointer Operations ---------------------------

procedure swapByPointer(ref a: Student, ref b: Student)
begin
    var temp: Student
    temp <- a
    a <- b
    b <- temp
end procedure

procedure pointerSwap()
begin
    var id1, id2: integer
    write("Enter first student ID to swap: ")
    read(id1)
    write("Enter second student ID to swap: ")
    read(id2)
    i1 <- findStudent(id1)
    i2 <- findStudent(id2)
    if (i1 == -1 OR i2 == -1) then
        write("Invalid IDs!")
        return
    end if
    swapByPointer(students[i1], students[i2])
    write("Records swapped successfully!")
end procedure

// --------------------------- Linked List History ---------------------------

procedure addHistory(var action: string, var id: integer)
begin
    var &newNode: Node
    newNode->action <- action
    newNode->id <- id
    newNode->next <- history
    history <- newNode
end procedure

procedure showHistory()
begin
    write("--- History ---")
    var *temp: Node <- history
    var count: integer <- 0
    while (temp != null AND count < 10) do
        write(temp->action + " (ID " + temp->id + ")")
        temp <- temp.next
        count <- count + 1
    end while
end procedure

// --------------------------- Undo / Redo System ---------------------------

procedure undo()
begin
    if (undoStack <- null) then
        write("Nothing to undo!")
        return
    end if
    var state_to_restore: Student <- undoStack.top()
    undoStack.pop()

    idx <- findStudent(state_to_restore.id)
    if (idx != -1) then
        redoStack.push(students[idx]) 
        
        students[idx] <- state_to_restore
        write("Undo performed.")
    else
        write("Undo performed, but original record location is lost.")
    end if
end procedure

procedure redo()
begin
    if (redoStack <- null) then
        write("Nothing to redo!")
        return
    end if
    var state_to_restore: Student <- redoStack.top()
    redoStack.pop()

    idx <- findStudent(state_to_restore.id)
    if (idx != -1) then
        undoStack.push(students[idx]) 
        students[idx] <- state_to_restore
        write("Redo performed.")
    else
        write("Redo performed, but record location is lost.")
    end if
end procedure

// --------------------------- Sorting Algorithms ---------------------------

procedure selectionSortByName(var arr: array of Student, var n: integer)
begin
    for (var i :integer <- 0; i < n - 1; i++) do
        var minIndex: integer <- i
        for (var j : integer <- i + 1; j < n; j++) do
            if (arr[j].name < arr[minIndex].name) then
                minIndex <- j
            end if
        end for
        if (minIndex != i) then
            swap(arr[i], arr[minIndex])
        end if
    end for
end procedure

procedure selectionSortByScore(var arr: array of Student, var n: integer)
begin
    for (var i :integer <- 0; i < n - 1; i++) do
        var maxIndex: integer <- i
        for (var j : integer <- i + 1; j < n; j++) do
            if (arr[j].score > arr[maxIndex].score) then
                maxIndex <- j
            end if
        end for
        if (maxIndex != i) then
            swap(arr[i], arr[maxIndex])
        end if
    end for
end procedure

procedure displaySortedByName()
begin
    var v: vector of Student
    for (var i : integer <-0, i < studentCount, i++) do
        if (students[i].valid) then
            v.push_back(students[i])
        end if
    end for
    sort v by name ascending
    write("--- Students Sorted by Name (A-Z) ---")
    for (each s in v) do
        s.display()
    end for
end procedure

procedure displaySortedByScore()
begin
    var v: vector of Student
    for (var i : integer <-0, i < studentCount, i++) do
        if (students[i].valid) then
            v.push_back(students[i])
        end if
    end for
    sort v by score descending
    write("--- Students Sorted by Score (High -> Low) ---")
    for (each s in v) do
        s.display()
    end for
end procedure

// --------------------------- Print Queue Manager ---------------------------

procedure enqueuePrint()
begin
    var id: integer
    write("Enter student ID to print: ")
    read(id)
    printQueue.push(id)
    addHistory("Queued Print", id)
    write("Added to print queue.")
end procedure

procedure processPrints()
begin
    write("--- Print Queue ---")
    var id: integer
    while (printQueue != null) do
        id <- printQueue.front()
        printQueue.pop()
        idx <- findStudent(id)
        if (idx != -1 AND students[idx].valid) then
            addHistory("Printed", id)
            write("Printing Report - " + students[idx].name + ": " + students[idx].score)
        else
            write("Student not found.")
        end if
    end while
end procedure

// --------------------------- Score Ranking Tree ---------------------------

function insert(var *root: TreeNode, var s: Student) : pointer to TreeNode
begin
    if (root == null) then
        var *node: TreeNode
        node->data <- s
        node->left <- null
        node->right <- null
        return node
    end if
    if (s->score < root->data->score) then
        root->left <- insert(root->left, s)
    else
        root->right <- insert(root->right, s)
    end if
    return root
end function

procedure inorder(var *root: TreeNode)
begin
    if (root == null) then
        return
    end if
    inorder(root.right)
    write(root->data->name + " (" + root->data->score + ")")
    inorder(root->left)
end procedure

procedure showRanking()
begin
    var *root: TreeNode <- null
    for (var i:integer <- 0; i < studentCount; i++) do
        if (students[i].valid) then
            root <- insert(root, students[i])
        end if
    end for
    write("--- Score Ranking (High to Low) ---")
    inorder(root)
end procedure

// --------------------------- Main Menu ---------------------------

function main() : integer
begin
    var choice: integer
    repeat
        write("Enter choice: ")
        read(choice)

        switch choice:
            case 1: addStudent(); addHistory("Added", nextId - 1); break
            case 2: deleteStudent(); addHistory("Deleted", nextId - 1); break
            case 3: showStudents(); break
            case 4: searchStudent(); break
            case 5: showReport(); break
            case 6: pointerSwap(); addHistory("Swapped", -1); break
            case 7: showHistory(); break
            case 8: undo(); addHistory("Undo", -1); break
            case 9: redo(); addHistory("Redo", -1); break
            case 10: displaySortedByScore(); break
            case 11: displaySortedByName(); break
            case 12: enqueuePrint(); break
            case 13: processPrints(); break
            case 14: showRanking(); break
            case 15: loadSampleData(); break
            case 0: write("Exiting..."); break
            default: write("Invalid choice!")
        end switch
    if (choice == 0) then
        return 0
    end if
end function